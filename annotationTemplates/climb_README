== Running MELD (services and client) ==

Quick start (for reference):

git clone https://github.com/oerc-music/meld
cd meld
git checkout fast-meld
pip install -r requirements.txt  #(or use a virtualenv) python manage.py runserver


== Creating a session ==

To start a new session (a new performance of a particular microcomposition), use the MELD session API as follows:

curl -H "Content-Type: application/json" -H "Slug: BaseCamp" -d '{
"@type": ["mo:Performance", "ldp:BasicContainer"], "mo:performance_of":
{ "@id": $SCORE_URI } }' -v http://127.0.0.1:5000/sessions

n.b., the Slug is optional (it just expresses a preference for the URI of the resulting session). 

The $SCORE_URI corresponds to the conceptual score that the session is presenting (mo:performance_of); see below. 

After the POST you should get back a response with status 201 and a "Location" header telling you the $SESSION_URI of the new session.

You can then load the session in-browser by going to:

http://127.0.0.1:8080/Climb?session=$SESSION_URI

== Conceptual scores ==

There is now a new layer of abstraction representing the conceptual musical score (for each microcomposition). The conceptual score is associated with an MEI file (representing the "published score") via the "mo:published_as" predicate.

Each conceptual score is associated with 0 or more muzicodes (conceived as triggerable-extents-in-the-score), each of which have their own URI.

Each muzicode is embodied by 1 or more elements of the *published* score (i.e., 1 or more MEI elements)

Annotations now target the muzicodes in the conceptual score, rather than the MEI elements directly. This has some nice advantages:

* We can now talk about a more sensible semantic entity, e.g. "Basecamp Choice 2" or "Bird attack", instead of having to use MEI UUIDs

* We can now map the semantic entity to a collection of multiple MEI elements, so we can highlight the "whole" muzicode when it spans more than one measure, for example.

Note that the score files have to be GENERATED by someone who knows more than me about the specifics of the muzicodes we have for Climb (you? Adrian?). I've created a little script to help with this:
       
meld/generate_scores.py

Run it as:

python generate_scores.py /path/to/scores.json http://uri/of/score/dir /filepath/of/score/dir/

The first argument is a file containing an array of simple JSON objects, one per score to be generated.

* Each score object has a scoreId which informs the filename and URI of the generated score.

* Each score object has a "mei" property which contains the URI to the MEI file of the published score.

* Each score object has an array of muzicode objects. Each of these has a muzicodeId (informing the muzicode's URI) and an array of MEI elements (measures, notes, ...) embodying the muzicode.

The second argument determines the base URI for the score and muzicode objects.

The third argument is the file path to the directory that serves the URI given in the second argument.

When the script is run, each score object will result in a corresponding turtle file, which will be placed in the score directory provided.

== Posting an annotation ==

Annotations are now posted directly to the session. You will need to add a "Content-Type" header with value "application/json" for the server to process them properly. To avoid race conditions and accidental overwriting, we use ETags (file hashes) which  need to be supplied with each POST. The sequence is as follows:

1. Perform a GET on the session URI, read the ETag header value from the response 2. POST the annotation to the session, supplying the same ETag value as  the "If-None-Match" header 3. Check the response status. If it's 201 (CREATED), we're done. If it's 412 (PRECONDITION FAILED), the file changed before our POST got through - so repeat from step 1.


== Types of annotation ==

The following annotations are currently supported:

Queue next session (assuming it's been created as specified above):
{
        "oa:hasTarget": { "@id": "$CURRENT_SESSION }, 
        "oa:hasBody": { "@id": $NEXT_SESSION },
        "oa:motivatedBy": { "@id": "motivation:queueNextSession" } }

Turn to next page or piece (the latter assumes a session has been
queued):
{ 
        "oa:hasTarget": { "@id": $CURRENT_SESSION },
        "oa:motiv
atedBy": { "@id": "motivation:nextPageOrPiece" } }


Identify the location of a muzicode in score:
{
        "oa:hasTarget": { "@id": $MUZICODE_URI },
        "oa:motivatedBy": { "@id": "motivation:muzicodeIdentify" } }

Indicate that a muzicode representing a *choice* has been triggered:
{
        "oa:hasTarget": { "@id": $MUZICODE_URI },
        "oa:motivatedBy": { "@id": "motivation:muzicodeChoice" } }

Indicate that a muzicode representing a *challenge* has been triggered:
{
        "oa:hasTarget": { "@id": $MUZICODE_URI },
        "oa:motivatedBy": { "@id": "motivation:muzicodeChallengePassed"
}
}

Indicate that a muzicode representing a Disklavier starting point has been triggered:
{
        "oa:hasTarget": { "@id": $MUZICODE_URI },
        "oa:motivatedBy": { "@id": "motivation:muzicodeDisklavierStart"
}
}


For the last four types of annotation, note that styling choices can be made in meld-companion/style/climb.css. Note also that the muzicodeIdentify style is overwritten by the muzicodeChoice, muzicodeChallengePassed, and muzicodeDisklavierStart styles.


